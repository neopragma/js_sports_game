9 Aug 2022

====================

Let's walk through the JavaSCript Game exercise.

Who wants to show their code?

----

Here's mine.

https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb/related?hl=en 

Choose "Launch app"

In the app window (browser tab) choose "Choose folder"

..../Projects/pluralsight/Liberty Mutual 2022/js_sports_game


Why do I have to run this in a browser instead of straight out of the files? It's because the app generates HTML on the fly using JavaScript, and the browser thinks that HTML came from a different domain than the original app. It's a security feature of browsers. When we run the app in its own browser, it doesn't trigger that security feature. So we have a browser running inside a broswer tab, implemented as a browser extension. 

Crazy. But also normal. Crazy is normal. Welcome to programming.



Sources:

js_sports_game/


Discussion points:

1. index.html. Looks different from the sample code. What do you notice that's different?

Some things they might notice

a. There are audio tags inside their own div. These definitions don't affect the appearance of the page. The audio clips are activated through JavaScript.

b. The script tag is coded outside the body container. Why does this work? (the browser loads whatever is in the html document from top to bottom. It doesn't care if the script tag is inside or outside the body container.)

c. The left and right divs are empty. In the sample code, there's a lot of html coded inside those divs. In this solution, most of that code is generated by JavaScript code.

2. The game.js JavaScript file probably looks a bit different than what you're used to seeing. What are some things you notice that are unfamiliar or different?

Some things they might notice 

a. Importing code from other JavaScript files.

b. Adding event listeners to divs instead of buttons. Why does that work? (You can add an event listener to any DOM element, including the document itself. When an event is fired on any element subordinate to the one that has the listener attached, the attached listener gets control. If your logic needs to distinguish which subordinate element fired the event, you have to write code to check it. This example doesn't do that, but you'll see that sort of thing later on.)

c. The code to add event listeners to the "shoot" buttons on the left and right sides is in a function instead of being coded inline. Why? (It's because that code refers to html elements that are not in the DOM until after some JavaScript code is executed to generate the html. The buttons don't exist at the time inline JavaScript is executed when the html document is loaded. When the browser loads inline JavaScript code, it runs the code. If it tried to run code that referenced the non-existent buttons, there would be a runtime error. So we call the function to generate the html code first, and later we can add eventlisteners to elements generated by that function.)

3. The team.js JavaScript file contains code that may be unfamiliar to you. This is an example of a constructor function. When called, it creates an instance of an object. The Team object encapsulates variables and a function that are associated with each Team object individually. 

Do you remember this concept from the video clip on Using Constructor Functions in the Pluralsight course JavaScript Objects, Prototypes, and Classes?

4. (team.js) You saw an example of the undefined keyword in the course videos you watched about arrays. Here's another use of undefined. The caller doesn't have to pass a value for strength when they call the constructor. The constructor will assign a default value of 50. 

5. (team.js) The team name we pass into the Team constructor gets assigned to two different instance variables - the displayName variable contains the value unchanged, and the name variable contains the value with embedded spaces removed. Why? Because that value is used to construct the ids of html elements, and those id values can't contain embedded spaces. 

6. (team.js) What type of value does function 'score' return? (let them answer). 

Let's figure it out.

All that stuff after the 'return' keyword is an expression. Remember the difference between a statement and an expression. The return statement in its entirety takes an action. The code after the return keyword doesn't take any action. It's an expression, so the interpreter will evaluate it to arrive at a single value. 

To evaluate the expression, the interpreter works from the innermost parentheses and moves outward.

So what is the first step in the evaluation of this expression? The first step is to call the Math.random() function. That function returns a value between zero and 1. So it's zero point something. Next, the interpreter multiplies that value by 100. That will get us a one or two digit number point something. 

Next, the interpreter passes the result it has so far into the Math.floor() function. That function returns the largest integer than is less than or equal to the argument. So if we had 18 point 627, Math.floor() would return 18. 

Finally, the interpreter executes the comparison: is 18 less than the strength of this Team. 

The idea of 'strength' in this code is that the number represents the team's chance of hitting the goal as a percentage. So, a team that has a 20 percent chance of making a goal would score when the expression evaluates to 18. There's a 20 percent chance the random value will be less than 20, because Math.floor() is going to return an integer between zero and 99. 

The result of the comparison is a boolean value - true or false. So, the score function returns a boolean value. 

7. Let's see what genHTML.js does. This code is generating the HTML for each side of the page. Instead of having almost identical hard-coded HTML for each side of the page, we can generate the HTML for each team, writing the JavaScript code just once. That way, when we need to maintain the application, we only have to modify the code in one place, and we won't make a mistake and have each side look or function differently. 

Going back to game.js, we see the genHTML function is called once for the left side and once for the right side. 

If we inspect the HTML document in the browser, we can see the HTML elements that were generated by the genHTML function. 


====================

The Array Archipelago - Array Ho!

Basic arrays
Array of arrays

1. Relating the material to the JavaScript Game exercise.

JavaScript Game

game.js

An example of an array. This one is an array of Team objects.

	let teams = [ teamAlpha, teamBeta ];

An example of a for loop. This one is a "for of" loop. 

	We declare a variable to represent each entry in turn, and after the "of" keyword we write the variable containing the array.
	"For of" iterates over the entries in an array in the order they were added to the array.
	We don't specify the indices with this form of the for loop.


	for (let team of teams) {
		team.shots = 0;
		team.goals = 0;
		counterID = "#" + team.name + "-numshots";
		document.querySelector(counterID).innerHTML = 0;
		counterID = "#" + team.name + "-numgoals";
		document.querySelector(counterID).innerHTML = 0;
	}

====================

2a. Challenge: Adjusting Array Contents

list[3] = 4;

2b. Array Functions

list.push(10);

2c. Building Arrays

let person = [ "string", 55, true ];

2d. Array Functions II

let bool = values.pop();

2e. 2D Arrays

let infant = eightiesMovies[1][4];
console.log(infant);

console.log(eightiesMovies[0][0] + eightiesMovies[0][1]);

====================

3. Searching Arrays video clip 

3a. Simplifying the addPassenger function.

Sample code:

function addPassenger ( name, list ) {
	if (list.length == 0) {
	    list.push(name);
	    return list;
	} else {
        for (let i = 0; i < list.length; i++) {
            if (list[i] == undefined) {
                list[i] = name;
                return list;
            } else if (i == list.length - 1) {
                list.push(name);
                return list;
            }
        }
	}
}

The function does not continue to run after a return statement. 

Therefore, we can simplify this code by removing unnecessary else expressions.

function addPassenger ( name, list ) {
	if (list.length == 0) {
	    list.push(name);
	    return list;
	}    
    for (let i = 0; i < list.length; i++) {
        if (list[i] == undefined) {
            list[i] = name;
            return list;
        } 
        if (i == list.length - 1) {
                list.push(name);
            }
        }
	}
	return list;
}

We also move the final return statement to the end of the function.

THis is safer than depending on the logic to fall through a series of if/else blocks correctly.


3b. Attaching the function directly to the object as a property of the object.

list.add = function add(name) { /* function code here */ } 

Then we can write 

list.add("Passenger Name");

====================

4. Challenges: Iteration over Array Contents.

unction isString(value){
  return typeof value == "string";
}

function numStrings(list) {
    let count = 0;
    for (let i = 0; i < list.length; i++) {
        if isString(list[i]) {
            count += 1;
        }
    }
    return count;
}

In the addPassenger function, we used the index value in the logic.

It made sense to use the basic form of the for loop, declaring an index variable and all that.

Here, we aren't using the index value for anything.

Can we simplify the for loop so that we don't have to create a variable for the index?

Earlier you saw an example of another form of the for statement, called for of.

Can we express the same logic using a for of statement?

function numStrings(list) {
    let count = 0;
    for (let entry of list) {
        if (isString(entry) {
            count += 1;
        }
    }
    return count;
}



====================

5. More about arrays.

What does a two-dimensional array remind you of? 

It reminds me of a spreadsheet.

Let's make a spreadsheet in JavaScript.

A small one - four across and four down.

let row = [ 0, 0, 0, 0 ];
let col = [ 0, 0, 0, 0 ];
let sheet = [ a, b ];

sheet[1][0] = 42;
sheet[1][0] = 42 / 2;
sheet[1][0]               contains 42 
sheet[1][1] = 21          contains 21

right answer, but what if we change the value in cell 1, 0?

sheet[1][0] = 44; 
sheet[1][1]              still contains 21 

but what we want is for cell 1, 1, to contain half the value in cell 1, 0. 

We can save a string representation of the formula in cell 1, 1.

sheet[1][1] = 'sheet[1][0] / 2';
sheet[1][1]              contains 'sheet[1][0] / 2'

Now we can write

eval(sheet[1][1]);       this displays the calculated result without changing the contents of cell 1, 1.

If we change cell 1, 0

sheet[1][0] = 86;

Now when we do this

eval(sheet[1][1]);      we get 43, which is half of 86. 

==================

Forest of Functions 

One question that came up last week was when do we need semicolons. This video clip gives one example - the function declaration for diffOfSquares does not end with a semicolon, but the function expression assigning the same function to variable diff does require a semicolon.

1. General questions/discussion 

1.1. When is a declared function loaded into memory? (when the program is loaded - in a web app, when the html document is loaded into the broswer)

1.2. When is a function expression loaded into memory? (when the line of code is reached during execution)

1.3. To use variable diff as a function, we have to pass the same argument list into it as we do when calling the declared function diffOfSquares.

1.4. What's an anonymous function? (a function expression without a function name - we call it via the variable name)

Let's try it with our is string function.


function numStrings(list) {
    let count = 0;
    for (let entry of list) {
        if (isString(entry) {
            count += 1;
        }
    }
    return count;
}

----------

let count = 0;
let isString = function (entry) { if (typeof entry == "string") count += 1; };

function numStrings(list) {
    let count = 0;
    for (let entry of list) {
        isString(entry);
    }
    return count;
}

What are the advantages of the first way?

What are the advantages of the second way?

-----------

Let's pause to clarify some terms. Carlos, like all the rest of us, sometimes uses language in an informal way or an imprecise way. That's okay as long as you understand the real meaning of the terms, so you'll know when it matters and when it doesn't.

Statement vs. expression. You know your programs execute one step at a time. A statement is the chunk of work the program does in a single step. An expression is a series of tokens that the interpreter evaluates and replaces with the result of the evaluation. 

So this is a statement:

let var3 = var1 % 2;

This part of the statement is an expression:

var1 % 2

So if the value of var1 happens to be 5 at the time the statement is executed, the statement is equivalent to

let var3 = 1;

In an earlier clip Carlos showed the for loop structure:

for (let i = 0 ; i < array.length ; i++)

and he said each of the three things within the parentheses is a statement.

What do you think? Are the statements or expressions?

Is it wrong or bad to say statement instead of expression? In most circumstances, it doesn't matter.

But in cases when it does matter, it's good to understand the difference.



Parameter vs. argument. 

Why do people use these two terms interchangeably?

Probably because they basically refer to the same things.

The parameters are the variable we define in a function declaration.

The arguments are the values passed to the function. That is, the contents of the variables.

Sometimes we pass literals into a function. Those are arguments.

But people are not always precise about these terms. 

The computer doesn't care what we call them. We could call them bananas and hammers. 


====================

Using Function Expressions 

Does anyone have questions or confusion about the information in this video? 

- storing a function in a variable
- passing a function into another function as an argument (like the national park terminal example)


====================

Challenges

Using Function Expressions with Parameters

let maxTrees = function ( acres ) {
	return acres * 720;
}

let tenAcresOfTrees = maxTrees(10);

----------

Function on the Fly

let diff = function ( a, b ) {
	return (a * a) - (b * b);
}

----------

Conditional Hello

function grabCondition() {
  return Math.round(Math.random()) % 2 == 0;
}

let helloMessage;
let condition = grabCondition();

if (condition) {
  helloMessage = function () {
    return "hello from if";
  }
} else {
  helloMessage = function () {
    return "hello from else";
  }
}
let message = helloMessage();


====================

Using Function Expressions (again)

06:55 to 07:28 old and new customer example using an if/else structure

Is there a more concise way to do the same thing?

walk through badlands.js, badlands2.js, and badlands3.js

====================

Using Function Expressions
Mapping Arrays with Function Expressions

The map() method - pattern

let results = numbers.map( function (arrayCell) {
	return arrayCell * 2;
});

----------

Using map() with function expressions

let windowPassengers = ['Winter', 'Whitney', 'Wesley'];
let aislePassengers = ['Aiden', 'Alex', 'Andy'];

let wp = windowPassengers.map(function(name) {
  return "W: " + name;
});
console.log(wp);

let ap = aislePassengers.map(function(name) {
  return "A: " + name;
});
console.log(ap);


Additional information: String interpolation

let wp = windowPassengers.map(function(name) {
  return `W: ${name}`;
});

The interpolated value can be an expression:

let wp = windowPassengers.map(function(name) {
  return `W: ${name.toUpperCase()}`;
});

or a more complicated expression:

let wp = windowPassengers.map(function(name) {
  return `W: ${name.toUpperCase()}` + " (Round Trip)";
});

----------

Array of Functions

let operations = [
  function(a, b) {
    return a + b;
  },
  function(a, b) {
    return a * b;
  },
  function(a, b) {
    return a - b;
  },
];

let results = operations.map(function(operation) {
    return operation(3,2);
});

console.log(results);

====================

Using Function Expressions As Return Values

Building a queue - FIFO 

x.push(item)

firstitem = x.shift();

----------

Editing entries in an array

let fruits = ['apple', 'grape'];
fruits.push('banana');

let extractFruit = function ( x ) { return x.shift(); };

console.log(extractFruit(fruits));

----------

Returning function expressions

let fruits = ['apple', 'grape'];
fruits.push('banana');

let extractFruit = function(f) {
    return function () { return "I picked: " + f.shift(); };
//    return function () { return `I picked: ${f.shift()`; };
};

let extract = extractFruit(fruits);


The version that uses string interpolatoini is also correct,
but the challenge does not recognize that solution,.

====================

Using Closures
Using Basic Closures

function construction zones

----------

Challenges: Closures

I'm not sure these challenges help us understand closures.
They seem to be more like match puzzles. 

function mystery() {
  let secret = 6;
  function mystery2(multiplier) {
    multiplier *= 3;
    return secret * multiplier;
  }
  return mystery2;
}

let hidden = mystery();
let result = hidden(3);

console.log('Result is: ' + result);

----------

Challenges: Closures Part II

function mystery(input) {
    let secret = 5;
    function mystery2(multiplier) {
   	 multiplier *= input;
   	 return secret * multiplier;
    }
    return mystery2;
}
let hidden = mystery(4);
let result = hidden(2);

console.log("Result is: " + result

----------
 
 Challenges: Closures Part III

 function mystery(input) {
  let secret = 4;
  input += 2;
  function mystery2(multiplier) {
    multiplier *= input;
    return secret * multiplier;
  }
  return mystery2;
}

function mystery3(param) {
  function mystery4(bonus) {
    return param(6) + bonus;
  }
  return mystery4;
}
let hidden = mystery(3);
let jumble = mystery3(hidden);
let result = jumble(2);

console.log('Result is: ' + result);

====================

Using Advanced Closures

Interesting point: Closures retain the value of their internal variables even after their scope is closed.

----------

Challenge: Building a Closure, Part I

function warningMaker(obstacle) {
    return function () { console.log("Beware! There have been " + obstacle + " sightings in the Cove togay");};
}; 

----------

Challenge: Using a Closure, Part I

function warningMaker(obstacle) {
  return function() {
    console.log('Beware! There have been ' + obstacle + ' sightings today!');
  };
}

let icebergAlert = warningMaker("iceberg");

icebergAlert();

----------

Challenge: Building a Closure, Part II

function warningMaker(obstacle) {
  return function(number, location) {
    console.log(
      'Beware! There have been ' +
        obstacle +
        ' sightings today! ' +
        number +
        ' have been spotted at the ' +
        location +
        '!'
    );
  };
}

This would be a good use case for string interpolation:

function warningMaker(obstacle) {
  return function(number, location) {
    console.log(
      `Beware! There have been ${obstacle} sightings today! ${number} have been spotted at the ${location}!`);
  };
}

----------

Using a Closure, Part II

function warningMaker(obstacle) {
  return function(number, location) {
    console.log(
      'Beware! There have been ' +
        obstacle +
        ' sightings today! ' +
        number +
        ' have been spotted at the ' +
        location +
        '!'
    );
  };
}

let killerPenguinAlert = warningMaker("killer penguin");
let polarBearAlert = warningMaker("polar bear");

killerPenguinAlert(6, "Ice Caves");
polarBearAlert(2, "Blizzard Beach");


On my first try, I capitalized Killer Penguin and Polar Bear, but the system expects them in lower case.

====================


What you've been working with so far illustrates the functional style of programming.

There are functional programming languages that enforce this style and provide compile-time support for strong typing and function operations.

JavaScript supports functional style programming and has some functions usually associated with functional languages, like the map function you saw earlier. It is not strictly speaking a functional language.

It is also not strictly speaking an object oriented language, but it also has support for the object oriented style of programming.

The next video course introduces this - JavaScript Objects, Prototypes, and Classes.

====================

Creating JavaScript Objects
Getting Started

github.com/jmcooper/javascript-opc

Creating and Using JavaScript Objects

Object Literals
Constructor Functions
Classes

Object Equality
Merging Properties
Mutability

----------

'use string';

----------

self-executing function (in an html document)

(function() {
	display('Hello World');
})();

----------

utils.js is interesting - lots of useful things are illustrated by that code 

Key points:

Objects are more complex variable types than simple numbers or strings.
Objects group information and functionality pertaining to a type together in a single variable.

----------

Object literal:

let person = {
	firstName: 'Jim',
	lastName: 'Cooper'
};

Use dot notation to refer to object properties

person.firstName;

----------

Adding a property to an object

person.age = 29;

Adding a method to an object

person.isAdult = function () { return this.age >= 18' }

Is the meaning of 'this' clear? 

----------

function registerUser(fName, lName) {
	let person = {
	    firstName: fName,
	    lastName: lName
	}:
	display(person);
}

registerUser('Kris','Jones');    
	}
}


// shorthand syntax

function registerUser(firstName, lastName) {
	let person = {
	    firstName,
	    lastName
	}:
	display(person);
}

// shorthand for methods


function registerUser(firstName, lastName) {
	let person = {
	    firstName,
	    lastName,
	    isAdult: function () { return this.age >= 18; }
	}:
	display(person);
}

function registerUser(firstName, lastName) {
	let person = {
	    firstName,
	    lastName,
	    isAdult() { return this.age >= 18; }
	}:
	display(person);
}

----------

JavaScript Object object

Object.keys() - discover all properties and methods on an object

returns array of strings with the names of the properties and methods

----------

for (let propertyName in person) {
	// gets all the property names
}

----------

Equality operators

==               recommended to avoid this generally

===              recommended in almost all cases

Object.is(o1,o2)      almost identical to === but not quite


==               not type safe

                 "42" == 42 

                 0 == false

                 null == undefined

                 "" == 0

                 [1,2] == "1,2"



===             type safe

                concise

                NaN === NaN   => false

                +0 == -0


Object.is()     type safe

                verbose

                Object.is(NaN1,NaN2)  => true

                Object.is(+0,-0)      => false

----------

Equality for objects is based on comparing the memory addresses of the objects

==================

Merge properties of objects 


let person1 = {
   firstName,
    lastName,
    isAdult() { return this.age >= 18; }
}:

let person2 = { };
Object.assign(person2, object1);

let healthStats = {
	height: 68,
	weight: 150
};

Object.assign(person1, healthStats);

----------

side effect

function mergeHealthStats(person1, healthStats) {
	return Object.assign(person1, healthStats);        <= person1 is mutated
}

function mergeHealthStats(person1, healthStats) {
	return Object.assign({ }, person1, healthStats);        <= new object is created, person1 is unchanged
}

let mergedPerson = mergeHealthStats(person1, healthStats);

====================

Constructor functions

function Person(firstName,lastName,age) {   // capitalized name is a convention - interpreter doesn't care
	this.firstName = firstName;             // semicolons here
	this.lastName = lastName;
	this.age = age;
	this.isAdult = function() { return this.age >= 18; }
}

let person = new Person('Jim', 'Cooper', 29);   // 'new' creates a new empty object
                                    // assigns 'this' to the new object
                                    // and calls the constructor function 


====================

Object.create() method

let person = Object.create(
    Object.prototype,
    {
        firstName: {value: 'Jim', enumerable: true, writable: true, configurable: true},
        --- etc ---
    }
);



====================

JavaScript Object Properties

bracket notation for properties 

instead of

person.firstName

you can write

person['firstName']


if you want a property name that isn't a valid js identifier (uncommon)

person['hair color'] = 'Brown';


if you have a variable that contains a property name (more common)

let propertyName = 'firstName';
person[propertyName]

for (let propertyName in person) {
	display(propertyName + ': ' + person[propertyName]);
}

----------

Properties have a property descriptor

Object.getOwnPropertyDescriptor(person, "firstName")

value: something
writable: boolean
enumerable; boolean
configurable: boolean

Object.defineProperty(person, 'firstName', {writable: false})

Now this fails:

person.firstName = 'Kris';

What if a non-writable property contains an object?

let person = {
	name: {
	    firstName: 'Jim',
	    lastName: 'Cooper'
	},
	age: 29;
};

Object.defineProperty(person, 'name', { writable: false });

Now this works:

person.name.firstName = 'Kris';

but this fails:

person.name = { };

Object.freeze(person.name);

Now this fails:

person.name.firstName = 'Kris';

----------

enumerable attribute

JSON.stringify - no 

----------

configurable attribute

can't change attributes
can't delete attributes from object
can't change configurable back again
but you can change the writable descriptor

delete person.firstName

===================

getters and setters 

Object.defineProperty(person, 'fullName'),
{
	get: function() {
	    return this.name.first + ' ' + this.name.last;
	},
	set: function(value) {
	    var nameParts = value.split(' ');
	    this.name.first = nameParts[0];
	    this.name.last = nameParts[1];
	}
})};

====================

Prototypes and Interfaces 

A function's prototype is the object instance that will become the prototype for all objects created using this function as a constructor.

An object's prototype is the object instance from which the object is inherited.

function Person(firstName, lastName) {
	this.firstName = firstName;
	this.lastName = lastName;
}

jim.hasOwnProperty('age'));
jim.age => comes from the prototype (__proto__.age)

====================

Object Inheritance

====================

Creating Your Own Prototypal Inheritance Chain

function Student(firstName, lastName, age) {
    Person.call(this, firstName, lastName, age);
	this.enrolledCourses = [];
	this.enroll = function(courseId) {
	    this.enrolledCourses.push(courseId);
	};
	this.getCourses = function () {
        return this.fullName + "'s enrolled courses are: "
            this.enrolledCourses.join(', ');
	};
}
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;

====================

class Person {
	constructor(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = 0;
	}
	get fullName() {
	    return this.firstName + ' ' + this.lastName;
	}
	set fullName(fullName) {
	    var nameParts = fullName.split(' ');
	    this.firstName = nameParts[0];
	    this.lastName = nameParts[1];
	}
	isAdult() { 
	    return this.age > 18;
	}
}

let jim = new Person('Jim', 'Cooper');
jim.age = 29;
console.log(jim.fullName);  <= referenced as a property, not as a method
console.log(jim.isAdult()); <= this one is a function

==========

Property Descriptors

getters and setters are created with enumerable = false

If you want them to show up, you have to set enumerable to true

getters and setters live on the prototype, not on the class/instances

they are not stateful - their values don't change

Outside the Person class:

Object.defineProperty(Person.prototype, 'fullName', {enumerable:true});

===========

Inheritance with Classes

class Student extends Person {
	constructor(firstName, lastName, age) {
	    super();                                 <= calls constructor of Person
	    this.enrolledCourses = [];
	}
	enroll(courseId) {
	    this.enrolledCourses.push(courseId);
	}
	getCourses() {
	    return this.fullName + "'s enrolled courses are: "
	        this.enrolledCourses.join(', ');
	}
}

----------

Discussion 

Why _enrolledCourses instead of enrolledCourses?

Does "Jim Cooper is enrolled in: blah, blah, blah" sound better than "enrolled classes are"?

----------

====================

Static Properties and Methods 

they live on the class, not the instance


class Student extends Person {
	constructor(firstName, lastName, age) {
	    super();                                 <= calls constructor of Person
	    this.enrolledCourses = [];
	}
	static fromPerson(person) {
	    return new Student(person.firstName, person.lastName, person.age);
	}
	enroll(courseId) {
	    this.enrolledCourses.push(courseId);
	}
	getCourses() {
	    return this.fullName + "'s enrolled courses are: "
	        this.enrolledCourses.join(', ');
	}
}

let jimStudent = Student.fromPerson(jim);


static function using functions instead of classes:

Student.fromPerson = function(person) {
	return new Student(person.firstName, person.lastName, person.age);
}

====================

Using the Math Object

You've already used Math.random() and possibly Math.floor()

Try Math.max() .(round) etc.

====================

Managing Dates with the Date Object

let date = new Date()               <= current date/time

let date = new Date(0)             <= milliseconds since Jan 1, 1970 UTC      17:00:00

let date = new Date(1000)           = 17:00:01

let date = new Date('2050-03-25T13:01:30Z');  <= ISO 8601 string (browsers are inconsistent)

let date = new Date(2050,3,25,13,1,30,50);   <= separate parts, year, month (0), day, hour, minute, second, millisecond

date.setMonth(5)    <= corresponding getters and setters

based on computer timezone or UTC

date.getUTCFullYear()    etc.


let date1 = new date(2050,3,25,13,1,30,50);
let date2 = new date(2050,3,25,13,1,30,55);

date2 - date1            5

let date1 = new date(2050,3,25,13,1,30,50);
let date2 = new date(2051,3,25,13,1,30,55);

date2 - date1            31536000005

===================

Validating Strings with the RegExp Object

function checkPasswordComplexity(password) {
	new regex = nre RegExp('^(?=.*[a-z])(?=.*\\d).{8,}$');
}
return regex.test(passwordStringValue);


Alternative syntax


function checkPasswordComplexity(password) {
	new regex = nre RegExp(/^(?=.*[a-z])(?=.*\d).{8,}$/);   <= no need to escape the \d
}
return regex.test(passwordStringValue);


This means the value must contain lower case characters, upper case characters, numbers, and is at least 8 characters long.


